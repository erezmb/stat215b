dffin$population[dffin$country %in% c("Cze")] <- 10.7
dffin$population[dffin$country %in% c("Swe")] <- 10.3
dffin$population[dffin$country %in% c("Por")] <- 10.3
dffin$population[dffin$country %in% c("Hun")] <- 9.8
dffin$population[dffin$country %in% c("Aus")] <- 8.9
dffin$population[dffin$country %in% c("Bul")] <- 7.0
dffin$population[dffin$country %in% c("Den")] <- 5.8
dffin$population[dffin$country %in% c("Fin")] <- 5.5
dffin$population[dffin$country %in% c("Slovakia")] <- 5.5
dffin$population[dffin$country %in% c("Ire")] <- 5.0
dffin$population[dffin$country %in% c("Cro")] <- 4.1
dffin$population[dffin$country %in% c("Lit")] <- 2.8
dffin$population[dffin$country %in% c("Slovenia")] <- 2.1
dffin$population[dffin$country %in% c("Lat")] <- 1.9
dffin$population[dffin$country %in% c("Est")] <- 1.3
# effective number of parties
# source: parlgov, downloaded on August 5, 2021
pg <- read.csv("data/parlgov/pg_aug2021.csv")
pg <- pg[!(as.numeric(substr(pg$election_date,1,4)) >= 2020 & pg$country_name == "Croatia"),]
pg <- pg[!(as.numeric(substr(pg$election_date,1,4)) >= 2020 & pg$country_name == "Ireland"),]
pg <- pg[!(as.numeric(substr(pg$election_date,1,4)) >= 2020 & pg$country_name == "Lithuania"),]
pg <- pg[!(as.numeric(substr(pg$election_date,1,4)) >= 2020 & pg$country_name == "Romania"),]
pg$start_date <- as.Date(pg$start_date)
lastcabs <- aggregate(pg$start_date, list(pg$country_name), max)
names(lastcabs) <- c("country_name","lastcabinet")
pg <- merge(pg, lastcabs, all.x = T, by = "country_name")
pg <- pg[pg$start_date == pg$lastcabinet,]
pg$country <- pg$country_name
pg$country <- substr(pg$country, 1,3)
pg$country[pg$country_name == "Slovenia"] <- "Slovenia"
pg$country[pg$country_name == "Slovakia"] <- "Slovakia"
pg$country[pg$country_name == "United Kingdom"] <- "UK"
pg <- pg[pg$country_name != "Australia",]
# According to Laakso and Taagepera (1979), the effective number of parties is computed by the following formula:
pg$seatshare <- pg$seats / pg$election_seats_total
pg$seatshare2 <- pg$seatshare ^2
stuff <- aggregate(pg$seatshare2, list(pg$country), sum)
names(stuff) <- c("country","sumsquaredseatshare")
stuff$eff_n_parties <-  1 / stuff$sumsquaredseatshare
dffin <- merge(dffin, stuff, all.x = T, by = "country")
# polarization ####
# cmp polarization:
# polarization (LR dimension)
# dalton index
cmp <- read.csv("data/cmp2020b.csv", stringsAsFactors = F)
cmp$election_date <- as.Date(cmp$edate, "%d/%m/%Y")
cmp <- cmp[cmp$election_date >= "1948-05-08" & cmp$election_date <= "2019-09-01",]
tmp <- aggregate( cmp$date, list(cmp$countryname), max)
names(tmp) <- c("countryname","lastelection_before_survey")
cmp <- merge(cmp, tmp, all.x = T, by = "countryname")
cmp <- cmp[cmp$date == cmp$lastelection,]
cmp <- cmp[cmp$eumember == 10,]
aggregate( cmp$date, list(cmp$countryname), max)
tmp <- aggregate(cmp$rile, list(cmp$countryname), mean, na.rm = T)
names(tmp) <- c("countryname","mean_rileposition")
cmp <- merge(cmp, tmp, all.x = T, by = "countryname")
cmp$weighted_deviations <- (cmp$rile - cmp$mean_rileposition)^2 * cmp$pervote / 100
tmp <- aggregate(cmp$weighted_deviations, list(cmp$countryname), mean, na.rm = T)
names(tmp) <- c("countryname","sum_weighted_deviations")
tmp$dalton_polarization_lr <- sqrt(tmp$sum_weighted_deviations)
cmp <- tmp
tmp <- data.frame(cbind(eu25=as.character(eu25), labcountries))
cmp <- merge(cmp, tmp , all.x = T, by.x = "countryname", by.y = "labcountries")
cmp$countryname <- cmp$sum_weighted_deviations <- NULL
dffin <- merge(dffin, cmp, all.x = T, by.x = "country", by.y = "eu25")
# logged average district magnitude (see Gidron et al. 2020)
# bormann et al data (source: http://mattgolder.com/elections)
bg <- read.dta13("data/bormann golder 2013/es_data-v3.dta")
bg$test <- as.numeric(bg$seats) / as.numeric(bg$tier1_districts)
tmp <- aggregate(bg$year,
list(country=bg$country),
max)
bg <- merge(bg, tmp, all.x = T, by = "country")
bg <- bg[bg$year == bg$x,]
bg <- subset(bg, select = c("country", "tier1_avemag"))
bg <- bg[bg$tier1_avemag != "NA",]
bg <- bg[!duplicated(bg),]
cdf <- data.frame(eu25,labcountries)
dffin <- merge(dffin, cdf, all.x = T, by.x = "country", by.y = "eu25")
rm(cdf)
dffin$labcountries <- as.character(dffin$labcountries)
unique(dffin$labcountries[!(dffin$labcountries %in% bg$country)])
dffin <- merge(dffin, bg, all.x = T, by.x = "labcountries", by.y = "country")
dffin$tier1_avemag <- as.numeric(dffin$tier1_avemag)
dffin$tier1_avemag[dffin$country == "Aus"] <- 4.26
dffin$tier1_avemag[dffin$country == "Por"] <- 10.45
dffin$tier1_avemag <- log(dffin$tier1_avemag)
aggregate(dffin$tier1_avemag, list(dffin$country), mean)
rm(bg)
# # bipolarity index : NPI (Maoz and Somer-Topcu) ####
cmp19b <- read.csv('data/cmp21a.csv', stringsAsFactors = F)
cmp19b <-cmp19b[cmp19b$countryname %in%  cmp19b$countryname[cmp19b$eumember == 10],]
cmp19b$party_seatshare <- cmp19b$absseat / cmp19b$totseats
wdf <- subset(cmp19b, select = c(countryname,date,party,rile,party_seatshare))
wdf$rile <- ( wdf$rile - min(wdf$rile, na.rm = T ) ) / ( max(wdf$rile, na.rm = T) - min(wdf$rile, na.rm = T ) )
summary(wdf$rile)
wdf$rile <- wdf$rile + 0.001
countries <- sort(unique(wdf$countryname))
country_npi <- list()
for ( country in 1:length(countries)){
countrydf <- wdf[wdf$countryname == countries[country],]
uniquedates <- unique(countrydf$date)
country_dates <- list()
for ( d in 1:length(uniquedates)){
electiondf <- countrydf[countrydf$date == uniquedates[d],]
tmpmat <- cbind(electiondf$party,
electiondf$rile)
# sorting step probably not necessary:
tmpmat <- tmpmat[order(tmpmat[,1]),]
# exclude parties with NA on position: no way to calculate their network position
tmpmat <- tmpmat[!is.na(tmpmat[,2]),]
# fix : positions cannot be exactly 0 or we get divide-by-zero error; correct by tiny constant #####
if ( min(tmpmat[,2]) <= 0){
tmpmat[,2] <- tmpmat[,2] + abs(min(tmpmat[,2])) + runif(1, 0.000001, 0.00001)
}
outmat <- cbind(tmpmat[,2]) %*% rbind(tmpmat[,2])
# standardize, right? ####
outmat_stdized <- outmat
for ( row in 1:nrow(outmat)){
for ( col in 1:nrow(outmat)){
outmat_stdized[row, col] <- outmat_stdized[row, col] / min(c (outmat[row, row], outmat[col, col]))
}
}
rownames(outmat_stdized) <- colnames(outmat_stdized) <- tmpmat[,1]
# actually mean, but median is more robust to distortions (this is also what they propose as an alternative, see maoz & st 2010, footnote 29)
outmat_stdized <- ifelse(outmat_stdized >= mean(outmat_stdized) , 1, 0)
# STEP 1: IDENTIFY PROTO-COALITIONS ####
# original: see notes dec 20, 2021 .R
e <- 1
candidatesets <- list()
for ( i in 2:nrow(outmat_stdized)){
(combinations <- combn(1:nrow(outmat_stdized), i))
for ( c in 1:ncol(combinations)){
combinations[,c]
submatrix <- outmat_stdized[c(combinations[,c] ), c(combinations[,c])]
# diagonal elements are always 1 (unit has relationship with itself) :
diag(submatrix) <- 1
indicator <- all(submatrix == 1)
if ( indicator == T){
candidatesets[[e]] <- combinations[,c]
e <- e + 1
}
}
}
# now drop perfect subsets
for ( e in 1:length(candidatesets)){
candidatesets[[e]]
for ( not_e in c(1:length(candidatesets))[!(1:length(candidatesets) %in% e)]){
if (all(candidatesets[[e]] %in% candidatesets[[not_e]]) == T ){
candidatesets[[e]] <- NA
}
}
}
for ( e in length(candidatesets):1){
if ( is.na(candidatesets[[e]][1] ) == T){
candidatesets[[e]] <- NULL
}
}
protocoalitions <- candidatesets
# are all parties covered?
coveredparties <- sort(unique(unlist(protocoalitions)))
stilltobecovered <- c(1:nrow(outmat_stdized))[!( c(1:nrow(outmat_stdized)) %in% coveredparties)]
# stilltobecovered <- c(444,666)
if ( length(stilltobecovered) > 0){
for ( i in 1:length(stilltobecovered))
protocoalitions[[length(protocoalitions) + 1]] <- stilltobecovered[i]
}
protocoalitions
# now for each pro-coalition i, compute
#  seat share p_i
#  cohesion c_i
coalition_stats <- list()
for ( i in 1:length(protocoalitions)){
# Seatshare ####
seatshare_i <- sum(electiondf$party_seatshare[electiondf$party %in% tmpmat[ protocoalitions[[i]] ,1]])
# Cohesion ####
# c_i = 1 - ( sqrt(sum sum (d_r - dq)^2 ) ) / ( s_i * (s_i - 1 ) * max(d) )
# (formula 1, p.8)
cohesion_i <- NA
protocoalitions[[i]]
if ( length(protocoalitions[[i]]) > 1){
sumvec <- NA
for ( j in 1:(length(protocoalitions[[i]])- 1) ){
d_r <- tmpmat[protocoalitions[[i]][j] ,2]
d_q <- tmpmat[protocoalitions[[i]][j +1] ,2]
sumvec[j] <- (d_r - d_q)^2
}
enumerator <- sqrt(sum(sumvec))
denominator <- length(protocoalitions[[i]]) * ( length(protocoalitions[[i]]) - 1) * max(tmpmat[protocoalitions[[i]], 2])
cohesion_i <- 1 - enumerator / denominator
} else {
# if a protocoalition consists of 1 party only, then cohesion is automatically 1
cohesion_i <- 1
}
coalition_stats[[i]] <- cbind(seatshare_i, cohesion_i)
}
coalition_stats <- do.call(rbind , coalition_stats)
# cpol = (4 * sum( p_i * (1-p_i) * c_i)) / k
cpol <- (4 * sum(coalition_stats[,1] * ( 1 - coalition_stats[,1] ) * coalition_stats[,2])) /
nrow(coalition_stats)
# create CA (parties x proto-coals)
ca <- matrix(0, nrow = nrow(tmpmat) , ncol = length(protocoalitions))
for ( i in 1:length(protocoalitions)){
ca[protocoalitions[[i]],i] <- 1
}
co <- t(ca) %*% ca
# standardize (also standardize diagonal entries?)
co_hat <- co
for ( row in 1:nrow(co)){
for ( col in 1:ncol(co)){
co_hat[row, col] <- co[row,col] / co[col,col]
}
}
coi <- ( sum(co_hat) - length(protocoalitions) ) / ( length(protocoalitions) * (length(protocoalitions) - 1) )
npi <- cpol * ( 1 - coi)
country_dates[[d]] <- data.frame(country=unique(electiondf$countryname),
electiondate=unique(electiondf$date),
npi=npi,
rile_sd=sd(electiondf$rile, na.rm = T))
} # end d-loop
country_npi[[country]] <- do.call(rbind, country_dates)
} # end country-loop
rm(list = ls())
library(lme4)
library(MASS)
library(foreign)
library(modelsummary) # for R2 stats
library(modelsummary) # for R2 stats
rm(list = ls())
# setwd("~")
load("data/aff_pol_df_analy_jan2023.RData")
# specify path of output file:
path <- "output"
# TABLE A1: Age breakdown #####
table(dffin$country, dffin$agegroup) / 6
# TABLE A2: Gender breakdown #####
table(dffin$country, dffin$sex) / 6
# TABLE C1: Treatment breakdown ####
summary(dffin$pl2gets)
sd(dffin$pl2gets)
table(dffin$diffsex)
table(dffin$diffage)
table(dffin$diffclass)
table(dffin$diffreligion)
table(dffin$nationality != "co-national")
table(dffin$outpartisan2)
lr.parties <- list(
# ordered list of party1, party2, ..., party8 by country
Aus = c("Österreichische Volkspartei (ÖVP)",
"Sozialdemokratische Partei Österreich (SPÖ)",
"Freiheitliche Partei Österreichs (FPÖ)",
"NEOS – Das Neue Österreich und Liberales Forum (NEOS)",
"Die Grünen – Die grüne Alternative (GRÜNE)",
"JETZT - Liste Pilz (JETZT)",
"EU-Austrittspartei (EUAUS)",
"Kommunistische Partei Österreichs (KPÖ)"),
Bel = c("Nieuw-Vlaamse Alliantie (N-VA)",
"Parti socialiste (PS)",
"Mouvement Réformateur (MR)",
"Christen-Democratisch en Vlaams (CD&V)",
"Open Vlaamse Liberalen en Democraten (Open Vld)",
"Socialistische Partij Anders (sp.a)",
"Centre démocrate humaniste (cdH)",
"Vlaams Belang (VB)"),
Bul = c("Граждани за европейско развитие на България (ГЕРБ)",
"Българска социалистическа партия (БСП)",
"Движение за права и свободи (ДПС)",
"ВМРО – Българско Национално Движение",
"Атака",
"Воля",
"Национален фронт за спасение на България (НФСБ)",
"Алтернатива за българско възраждане (АБВ)"),
Cro = c("Hrvatska demokratska zajednica (HDZ)",
"Socijaldemokratska partija Hrvatske  (SDP)",
"Živi zid",
"Most nezavisnih lista (MOST)",
"Hrvatska seljačka stranka  (HSS)",
"Bandić Milan 365 - Stranka rada i solidarnosti (BM365)",
"Bruna Esih – Zlatko Hasanbegović: Neovisni za Hrvatsku (NHR)",
"Pametno"),
Cze = c("ANO 2011 (ANO)",
"Občanská demokratická strana (ODS)",
"Česká pirátská strana (Piráti)",
"Svoboda a přímá demokracie (SPD)",
"Komunistická strana Čech a Moravy (KSČM)",
"Česká strana sociálně demokratická (ČSSD)",
"Křesťanská a demokratická unie - Československá strana lidová (KDU-ČSL)",
"Tradice Odpovědnost Prosperita 09 (TOP 09)"),
Den = c("Socialdemokratiet (A)",
"Venstre (V)",
"Dansk Folkeparti (O)",
"Det Radikale Venstre (B)",
"Socialistisk Folkeparti (F)",
"Enhedslisten – De rød-grønne (Ø)",
"Liberal Alliance (I)",
"Alternativet (Å)"),
Est = c("Eesti Reformierakond (ER)",
"Eesti Keskerakond (KE)",
"Eesti Konservatiivne Rahvaerakond (EKRE)",
"Sotsiaaldemokraatlik Erakond (SDE)",
"Isamaa (I)",
"Eesti 200",
"Erakond Eestimaa Rohelised (EER)",
"Eesti Vabaerakond (EVA)"),
Fin = c("Suomen Sosialidemokraattinen Puolue (SDP)",
"Kansallinen Kokoomus (KOK)",
"Perussuomalaiset (PS)",
"Suomen Keskusta (KESK)",
"Vihreä liitto (VIHR)",
"Vasemmistoliitto (VAS)",
"Svenska folkpartiet i Finland (SFP (Suomen ruotsalainen kansanpuolue (RKP)))",
"Kristillisdemokraatit (KD)"),
Fra = c("La République En Marche (REM)",
"Les Républicains (LR)",
"Rassemblement national (RN (ex. Front National (FN)))",
"La France Insoumise (FI)",
"Parti Socialiste (PS)",
"Europe Écologie-Les Verts (EELV)",
"Debout la France (DLF)",
"Génération.s"),
Ger = c("Christlich Demokratische Union (CDU)",
"Christlich Soziale Union (CSU)",
"Sozialdemokratische Partei Deutschlands (SPD)",
"Alternative für Deutschland (AfD)",
"Freie Demokratische Partei (FDP)",
"Die Linke (Linke)",
"Bündnis 90 / Die Grünen (Grüne)",
"Freie Wähler (FW)"),
Gre = c("Nέα Δημοκρατία (NΔ)",
"Συνασπισμός Ριζοσπαστικής Αριστεράς (ΣΥ.ΡIΖ.Α)",
"Πανελλήνιο Σοσιαλιστικό ίνημα (ΠΑΣΟK)",
"Κίνημα Δημοκρατών Σοσιαλιστών (ΚΙΔΗΣΟ)",
"Λαϊκός Σύνδεσμος -Χρυσή Αυγή (ΛΣ-ΧΑ)",
"Kομμουνιστικό Kόμμα Ελλάδας (KKΕ)",
"Ένωση Κεντρώων (EK)",
"Ανεξάρτητοι Έλληνες (ΑΝΕΛ)"),
Hun = c("Fidesz – Magyar Polgári Szövetség (FIDESZ)",
"Kereszténydemokrata Néppárt (KDNP)",
"Jobbik Magyarországért Mozgalom (JOBBIK)",
"Magyar Szocialista Párt (MSZP)",
"Párbeszéd Magyarországért (Párbeszéd)",
"Demokratikus Koalíció (DK)",
"Momentum Mozgalom (Momentum)",
"Lehet Más a Politika (LMP)"),
Ire = c("Fine Gael (FG)",
"Fianna Fáil (FF)",
"Sinn Féin (SF)",
"Labour Party (LP)",
"Independent Alliance",
"Solidarity - People Before Profit (Solidarity-PBP)",
"Social Democrats (Daonlathaigh Shóisialta)",
"Green Party"),
Ita = c("Lega (Lega Salvini Premier)",
"Movimento 5 Stelle (M5S)",
"Partito Democratico (PD)",
"Forza Italia (FI)",
"Fratelli d'Italia (FDI)",
"Più Europa (+E)",
"Sinistra Italiana (SI)",
"Possibile (P)"),
Lat = c("Sociāldemokrātiskā partija „Saskaņa“ (SDP)",
"Jaunā konservatīvā partija (JKP)",
"Zaļo un Zemnieku savienība (ZZS: Latvijas Zemnieku savienība (LZS) + Latvijas Zaļā partija (LZP))",
"Nacionālā apvienība „Visu Latvijai!” – „Tēvzemei un Brīvībai/LNNK” (NA)",
"'Kam pieder valsts' (KPV LV)",
"Kustība Par! (Par!)",
"Latvijas attīstībai (LA)",
"Vienotība (V)"),
Lit = c("Tėvynės sąjunga - Lietuvos krikščionys demokratai (TS-LKD)",
"Lietuvos valstiečių ir žaliųjų sąjunga (LVŽS)",
"Lietuvos socialdemokratų partija (LSDP)",
"Tvarka ir teisingumas (TT)",
"Darbo partija (DP)",
"Lietuvos socialdemokratų darbo partija (LSDDP)",
"Lietuvos centro partija (LCP)",
"Lietuvos lenkų rinkimų akcija – Krikščioniškų šeimų sąjunga (LLRA–KŠS)"),
Net = c("Volkspartij voor Vrijheid en Democratie (VVD)",
"Partij voor de Vrijheid (PVV)",
"GroenLinks (GL)",
"Christen-Democratisch Appèl (CDA)",
"Democraten 66 (D66)",
"Socialistische Partij (SP)",
"Partij van de Arbeid (PvdA)",
"Forum voor Democratie (FvD)"),
Pol = c("Prawo i Sprawiedliwość (PiS)",
"Platforma Obywatelska (PO)",
"Wiosna",
"Kukuiz'15",
"Polskie Stronnictwo Ludowe (PSL)",
"Sojusz Lewicy Demokratycznej (SLD)",
".Nowoczesna (.N)",
"Partia Roberta Biedronia"),
Por = c("Partido Socialista (PS)",
"Partido Social Democrata (PSD)",
"Centro Democrático e Social – Partido Popular (CDS-PP)",
"Bloco de Esquerda (BE)",
"Partido Comunista Português (PCP)",
"Partido Ecologista 'os Verdes' (PEV)",
"Partido Democrático Republicano (PDR)",
"Aliança"),
Rom = c("Partidul Social Democrat (PSD)",
"Partidul Național Liberal (PNL)",
"Alianța Liberalilor și Democraților (ALDE)",
"Uniunea Salvați România (USR)",
"PRO România (PRO)",
"Uniunea Democrată Maghiară din România (UDMR - Romániai Magyar Demokrata Szövetség (RMDSZ))",
"Partidul Libertății Unității și Solidarității (PLUS)",
"Partidul Mișcarea Populară (PMP)"),
Slovakia = c("Smer – sociálna demokracia (Smer-SD)",
"Sloboda a Solidarita (SaS)",
"Obyčajní Ľudia a nezávislé osobnosti (OĽaNO)",
"Kotleba – Ľudová strana Naše Slovensko (ĽSNS)",
"Progresívne Slovensko (PS)",
"SME RODINA – Boris Kollár (SME RODINA)",
"Kresťanskodemokratické hnutie (KDH)",
"Slovenská národná strana (SNS)"),
Slovenia = c("Lista Marjana Šarca (LMŠ)",
"Slovenska demokratska stranka (SDS)",
"Socialni demokrati (SD)",
"Levica",
"Stranka modernega centra (SMC)",
"Nova Slovenija - Krščanski demokrati (N.Si)",
"Slovenska nacionalna stranka (SNS)",
"Stranka Alenke Bratušek"),
Spa = c("Partido Socialista Obrero Español (PSOE)",
"Partido Popular (PP)",
"Ciudadanos - Partido de la Ciudadanía (C's)",
"Podemos",
"Vox",
"Izquierda Unida (IU)",
"Esquerra Republicana de Catalunya (ERC)",
"Partit Demòcrata Europeo Català (PDeCAT)"),
Swe = c("Socialdemokratiska arbetarpartiet (SAP)",
"Sverigedemokraterna (SD)",
"Moderata samlingspartiet (M)",
"Kristdemokraterna (KD)",
"Vänsterpartiet (V)",
"Centerpartiet (C)",
"Miljöpartiet de Gröna (MP)",
"Liberalerna (L)"),
UK = c("Labour Party (Labour)",
"Conservative and Unionist Party (Conservative Party)",
"Brexit Party",
"Liberal Democrats (Lib Dem)",
"Scotish National Party (SNP)",
"Green Party of England and Wales (GP)",
"Change UK – The Independent Group",
"UK Independence Party (UKIP)")
)
no.party.response <- c(
# Q52 response indicating no party
Aus="Nein, ich stehe keiner politischen Partei nahe",
Bel="Nee, ik voel mij niet verbonden met een politieke partij",
Bul="Не, не се чувствате близък/а до която и да е политическа партия",
Cro="Ne, ne osjećate bliskost prema nijednoj političkoj stranci",
Cze="Ne, žádná politická strana vám nepřijde blízká",
Den="Nej, du føler ikke, at dine holdninger ligger tæt op ad et af de politiske partier",
Est="Ei, Te ei tunne end lähedasena mitte ühegi poliitilise erakonnaga",
Fin="En tunne olevani läheinen minkään poliittisen puolueen kanssa",
Fra="Non, je ne me sens proche d’aucun parti politique",
Ger="Nein, ich stehe keiner politischen Partei nahe",
Gre="Όχι, δεν συμμερίζεστε τις απόψεις κανενός πολιτικού κόμματος",
Hun="Nem, nem érzi magát közelinek egy politikai párthoz sem",
Ire="No, I do not feel close to any political party",
Ita="No, non mi sento vicino a nessun partito politico in particolare",
Lat="Nē, es nejūtos pietuvināts(-a) nevienai politiskajai partijai",
Lit="Ne, Aš nesijaučiu artimas (-a) jokiai politinei partijai",
Net="Nee, u voelt zich niet verbonden met één bepaalde politieke partij",
Pol="Nie, żadna partia polityczna nie jest Panu(i) bliska",
Por="Não, não se sente próximo de nenhum partido político",
Rom="Nu, nu vă consideraţi apropiat(ă) de niciun partid politic",
Slovakia="Nie, necítim afinitu k žiadnej politickej strane",
Slovenia="Ne počutite se blizu nobeni politični stranki",
Spa="No, no me siento próximo/a a ningún partido",
Swe="Nej, du anser dig inte stå nära något politiskt",
UK="No, I do not feel close to any political party")
inner.match <- function(x, nm, l) {
# look for the index of x in l[[nm]]
stopifnot(length(x) == length(nm))
l.ln <- sapply(l, length)
l.nm <- rep(names(l), l.ln)
l.loc <- l.nm != c(paste0("!", head(l.nm, 1)), head(l.nm, -1))
l.offset <- cumsum(l.loc * unname(rep(l.ln, l.ln))) - l.ln[1]
l.idx <- 1:length(l.nm) - l.offset
l.idx[match(paste(nm, x), paste(l.nm, unlist(l, use.names=F)))]
}
na.set <- function(x, val) ifelse(is.na(x), val, x)
encode.party <- function(party.nm, country) {
# party name to {1, 2, ..., 8, None, Other}
ifelse(party.nm == no.party.response[country], "None",
na.set(inner.match(party.nm, country, lr.parties), "Other"))
}
get.cols <- function(idx, cols) {
# returns out[i] = cols[idx[i]]
stopifnot(length(idx) == nrow(cols))
vcols <- unlist(cols, use.names=F)
suppressWarnings(idx <- as.numeric(idx))
vcols[1:length(idx) + (idx - 1) * nrow(cols)]
}
enrich.party.stance <- function(data) {
# add columns with information on party stance
within(data, {
player1.lrpos <- lrpos
player1.party <- encode.party(Q52, country);
player2.party <- encode.party(partydrawn, country);
player1.party.lrpos <- get.cols(player1.party, data[,paste0("lrpos_party", 1:8)]);
player2.party.lrpos <- get.cols(player2.party, data[,paste0("lrpos_party", 1:8)]);
})
}
analyze.party.stance <- function(data) {
}
rm(list = ls())
